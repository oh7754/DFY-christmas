<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ÌÅ¨Î¶¨Ïä§ÎßàÏä§ Ìä∏Î¶¨ Í∞§Îü¨Î¶¨</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 16px;
      left: 16px;
      padding: 12px 16px;
      background: rgba(15,23,42,0.9);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      z-index: 10;
    }
    #ui h1 {
      font-size: 16px;
      margin-bottom: 8px;
    }
    #fileInput {
      margin-top: 6px;
      font-size: 12px;
    }
    #count {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.8;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>üéÑ ÌÅ¨Î¶¨Ïä§ÎßàÏä§ Ìä∏Î¶¨ Í∞§Îü¨Î¶¨</h1>
    <div style="font-size: 13px;">Ïù¥ÎØ∏ÏßÄÎ•º Ïò¨Î¶¨Î©¥ Ìä∏Î¶¨Ïóê Í±∏Î†§Ïöî.</div>
    <input id="fileInput" type="file" multiple accept="image/*" />
    <div id="count">Í±∏Î¶∞ ÏÇ¨ÏßÑ: 0Ïû•</div>
  </div>

  <!-- three.js (r150.1, ÏòàÏ†Ñ Î∞©Ïãù ÏßÄÏõê) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

  <script type="module">
  // ===== Firebase CDN import =====
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js';
  import {
    getFirestore,
    collection,
    addDoc,
    onSnapshot,
    query,
    orderBy,
    serverTimestamp
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js';
  import {
    getStorage,
    ref,
    uploadBytes,
    getDownloadURL
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-storage.js';

  // === Ïó¨Í∏∞Î•º Firebase ÏΩòÏÜîÏóêÏÑú Î≥µÏÇ¨Ìïú Í±∏Î°ú Î∞îÍøî ÎÑ£Í∏∞ ===
  const firebaseConfig = {
    apiKey: "AIzaSyABAGj8HWNDnkOjh5LHowEhdJ8k7lJl-iw",
    authDomain: "dfy-christmas-tree.firebaseapp.com",
    projectId: "dfy-christmas-tree",
    storageBucket: "dfy-christmas-tree.firebasestorage.app",
    messagingSenderId: "135069318422",
    appId: "1:135069318422:web:964fe40466315026612437",
    measurementId: "G-0XVMXDFJM7"
  };
  // =============================================

  // Firebase Ï¥àÍ∏∞Ìôî
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const storage = getStorage(app);
  const imagesCol = collection(db, "treeImages"); // Ïª¨Î†âÏÖò Ïù¥Î¶Ñ

  // Ïù¥ÎØ∏ Ìä∏Î¶¨Ïóê Ï∂îÍ∞ÄÌïú Î¨∏ÏÑú id Í∏∞ÏñµÏö©
  const shownImageIds = new Set();

  window.addEventListener("load", () => {
    console.log("ÌéòÏù¥ÏßÄ Î°úÎìúÎê®");

    // === Ïó¨Í∏∞Î∂ÄÌÑ∞Îäî Í∏∞Ï°¥ three.js ÏΩîÎìú Í∑∏ÎåÄÎ°ú Î≥µÎ∂ô (scene, camera, treeGroup Îì±) ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 6, 14);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x223355, 0.8);
    hemiLight.position.set(0, 1, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    const groundGeo = new THREE.CircleGeometry(18, 64);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x0b1220,
      metalness: 0.2,
      roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const treeHeight = 8;
    const treeRadius = 3;

    const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 1.5, 16);
    const trunkMat = new THREE.MeshStandardMaterial({
      color: 0x5b3a1e,
      roughness: 0.9
    });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 0.75;
    treeGroup.add(trunk);

    const treeGeo = new THREE.ConeGeometry(treeRadius, treeHeight, 32, 1, true);
    const treeMat = new THREE.MeshStandardMaterial({
      color: 0x0f766e,
      roughness: 0.6,
      metalness: 0.2
    });
    const tree = new THREE.Mesh(treeGeo, treeMat);
    tree.position.y = 0.75 + treeHeight / 2;
    treeGroup.add(tree);

    const starGeo = new THREE.OctahedronGeometry(0.4);
    const starMat = new THREE.MeshStandardMaterial({
      color: 0xfacc15,
      emissive: 0xfacc15,
      emissiveIntensity: 0.6,
      metalness: 0.9,
      roughness: 0.3
    });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.y = tree.position.y + treeHeight / 2 + 0.8;
    treeGroup.add(star);

    const snowCount = 600;
    const snowGeo = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(snowCount * 3);
    for (let i = 0; i < snowCount; i++) {
      snowPositions[i * 3 + 0] = (Math.random() - 0.5) * 40;
      snowPositions[i * 3 + 1] = Math.random() * 20 + 2;
      snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
    }
    snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPositions, 3));
    const snowMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.06
    });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    const countEl = document.getElementById("count");
    function updateCount(num) {
      countEl.textContent = `Í±∏Î¶∞ ÏÇ¨ÏßÑ: ${num}Ïû•`;
    }

    function getRandomPositionOnTree() {
      const yMin = tree.position.y - treeHeight / 2 + 0.5;
      const yMax = tree.position.y + treeHeight / 2 - 0.5;
      const y = yMin + Math.random() * (yMax - yMin);
      const normalizedHeight =
        (y - (tree.position.y - treeHeight / 2)) / treeHeight;
      const radiusAtY = treeRadius * (1 - normalizedHeight) + 0.2;

      const angle = Math.random() * Math.PI * 2;
      const x = Math.cos(angle) * radiusAtY;
      const z = Math.sin(angle) * radiusAtY;

      const position = new THREE.Vector3(x, y, z);
      return { position };
    }

    // --- Ïù¥ÎØ∏ÏßÄ Ìïú Ïû•ÏùÑ Ìä∏Î¶¨Ïóê Ï∂îÍ∞Ä ---
    function addImageToTree(imageUrl) {
      const texLoader = new THREE.TextureLoader();
      texLoader.load(
        imageUrl,
        (texture) => {
          const aspect = texture.image.width / texture.image.height;
          const baseHeight = 1.0;
          const width = baseHeight * aspect;
          const height = baseHeight;

          const geo = new THREE.PlaneGeometry(width, height);
          const mat = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(geo, mat);

          const { position } = getRandomPositionOnTree();
          plane.position.copy(position);
          plane.lookAt(new THREE.Vector3(0, position.y, 0));
          plane.rotateY(Math.PI);

          treeGroup.add(plane);
        },
        undefined,
        (err) => {
          console.error("ÌÖçÏä§Ï≤ò Î°úÎìú Ïò§Î•ò", err);
        }
      );
    }

    // --- FirestoreÏóêÏÑú Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ïù¥ÎØ∏ÏßÄ Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞ ---
    const q = query(imagesCol, orderBy("createdAt", "asc"));
    onSnapshot(q, (snapshot) => {
      console.log("Firestore snapshot size:", snapshot.size); // ÎîîÎ≤ÑÍ∑∏Ïö© Î°úÍ∑∏

      // Ïò§Î•∏Ï™Ω Ï∞ΩÏ≤òÎüº ÏÉàÎ°ú Îì§Ïñ¥Ïò® ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÎèÑ
      // ÌòÑÏû¨ Ï°¥Ïû¨ÌïòÎäî Î™®Îì† Î¨∏ÏÑúÎ•º Ìïú Î≤àÏî© Ï≤òÎ¶¨Ìï¥ Ï§ÄÎã§.
      snapshot.docs.forEach((doc) => {
        const id = doc.id;
        if (shownImageIds.has(id)) return;   // Ïù¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÏÑú Ïù¥ÎØ∏ Î∂ôÏù∏ Í±¥ Ïä§ÌÇµ
        shownImageIds.add(id);

        const data = doc.data();
        if (data.url) {
          console.log("addImageFromDoc:", id, data.url); // ÎîîÎ≤ÑÍ∑∏Ïö©
          addImageToTree(data.url);
        }
      });

      // Ï¥ù Í∞úÏàò UI ÏóÖÎç∞Ïù¥Ìä∏
      updateCount(snapshot.size);
    });



    // --- ÌååÏùº ÏóÖÎ°úÎìú ‚Üí StorageÏóê Ïò¨Î¶¨Í≥† URLÏùÑ FirestoreÏóê Ï†ÄÏû• ---
    async function uploadAndRegister(file) {
      const filePath = `uploads/${Date.now()}_${file.name}`;
      const storageRef = ref(storage, filePath);
      const snapshot = await uploadBytes(storageRef, file);
      const downloadURL = await getDownloadURL(snapshot.ref);

      await addDoc(imagesCol, {
        url: downloadURL,
        createdAt: serverTimestamp()
      });
    }

    const fileInput = document.getElementById("fileInput");
    fileInput.addEventListener("change", (event) => {
      const files = event.target.files;
      if (!files || !files.length) return;

      Array.from(files).forEach((file) => {
        if (!file.type.startsWith("image/")) return;
        uploadAndRegister(file).catch((err) =>
          console.error("ÏóÖÎ°úÎìú Ïã§Ìå®", err)
        );
      });

      fileInput.value = "";
    });

    // === ÎìúÎûòÍ∑∏ ÌöåÏ†Ñ / Ìú† Ï§å, Î¶¨ÏÇ¨Ïù¥Ï¶à, Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ (Í∏∞Ï°¥ ÏΩîÎìú Í∑∏ÎåÄÎ°ú) ===
    let isDragging = false;
    let prevX = 0;
    let prevY = 0;
    const dragRotateSpeed = 0.005;

    renderer.domElement.addEventListener("mousedown", (event) => {
      isDragging = true;
      prevX = event.clientX;
      prevY = event.clientY;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });

    window.addEventListener("mousemove", (event) => {
      if (!isDragging) return;
      const deltaX = event.clientX - prevX;
      const deltaY = event.clientY - prevY;
      prevX = event.clientX;
      prevY = event.clientY;

      treeGroup.rotation.y += deltaX * dragRotateSpeed;
      const newX = THREE.MathUtils.clamp(
        treeGroup.rotation.x + deltaY * dragRotateSpeed,
        -Math.PI / 6,
        Math.PI / 6
      );
      treeGroup.rotation.x = newX;
    });

    renderer.domElement.addEventListener("wheel", (event) => {
      event.preventDefault();
      const zoomSpeed = 0.002;
      const delta = event.deltaY * zoomSpeed;
      const minDist = 8;
      const maxDist = 25;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      const newPos = camera.position.clone().addScaledVector(dir, delta * 20);
      const distance = newPos.length();

      if (distance > minDist && distance < maxDist) {
        camera.position.copy(newPos);
      }
    }, { passive: false });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    let lastTime = 0;
    function animate(time) {
      requestAnimationFrame(animate);
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (!isDragging) {
        treeGroup.rotation.y += delta * 0.2;
      }
      star.rotation.y -= delta * 0.4;

      const pos = snowGeo.attributes.position;
      for (let i = 0; i < snowCount; i++) {
        let y = pos.getY(i);
        y -= delta * (0.5 + Math.random() * 0.3);
        if (y < 0.5) {
          y = Math.random() * 20 + 5;
        }
        pos.setY(i, y);
      }
      pos.needsUpdate = true;

      camera.lookAt(0, tree.position.y, 0);
      renderer.render(scene, camera);
    }
    animate(0);
  });
</script>

</body>
</html>
