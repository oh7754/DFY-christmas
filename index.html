<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ÌÅ¨Î¶¨Ïä§ÎßàÏä§ Ìä∏Î¶¨ Í∞§Îü¨Î¶¨</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 16px;
      left: 16px;
      padding: 12px 16px;
      background: rgba(15,23,42,0.9);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      z-index: 10;
      max-width: 260px;
    }
    #ui h1 {
      font-size: 16px;
      margin-bottom: 8px;
    }
    #fileInput {
      margin-top: 6px;
      font-size: 12px;
    }
    #count {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.8;
    }
    button {
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      background: #22c55e;
      color: #022c22;
    }
    button.secondary {
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>üéÑ ÌÅ¨Î¶¨Ïä§ÎßàÏä§ Ìä∏Î¶¨ Í∞§Îü¨Î¶¨</h1>
    <div style="font-size: 13px;">Ïù¥ÎØ∏ÏßÄÎ•º Ïò¨Î¶¨Î©¥ Ìä∏Î¶¨Ïóê Í±∏Î†§Ïöî.</div>

    <!-- Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú ÌëúÏãú -->
    <div id="userInfo"
         style="margin-top: 6px; font-size: 12px; opacity: .9;">
      Î°úÍ∑∏Ïù∏ ÌïÑÏöî (ÏÇ¨ÎÇ¥ Íµ¨Í∏Ä Í≥ÑÏ†ïÎßå Í∞ÄÎä•)
    </div>

    <!-- Î°úÍ∑∏Ïù∏ / Î°úÍ∑∏ÏïÑÏõÉ Î≤ÑÌäº -->
    <div style="margin-top: 6px; display: flex; gap: 6px;">
      <button id="loginBtn">Google Í≥ÑÏ†ïÏúºÎ°ú Î°úÍ∑∏Ïù∏</button>
      <button id="logoutBtn" class="secondary" style="display:none;">
        Î°úÍ∑∏ÏïÑÏõÉ
      </button>
    </div>

    <!-- ÌååÏùº ÏóÖÎ°úÎìú -->
    <input id="fileInput" type="file" multiple accept="image/*" disabled />
    <div id="count">Í±∏Î¶∞ ÏÇ¨ÏßÑ: 0Ïû•</div>
  </div>

  <!-- three.js (r150.1, ÏòàÏ†Ñ Î∞©Ïãù ÏßÄÏõê) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

  <script type="module">
  // ===== Firebase CDN import =====
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js';
  import {
    getFirestore,
    collection,
    addDoc,
    onSnapshot,
    query,
    orderBy,
    serverTimestamp
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js';
  import {
    getStorage,
    ref,
    uploadBytes,
    getDownloadURL
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-storage.js';
  import {
    getAuth,
    onAuthStateChanged,
    signInWithPopup,
    GoogleAuthProvider,
    signOut
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js';

  // === Firebase ÏÑ§Ï†ï ===
  const firebaseConfig = {
    apiKey: "AIzaSyB_bZoaw6cvdrot7DEabrXsfyDYM-ZgaR0",
    authDomain: "dfy-christmas-tree-452d4.firebaseapp.com",
    projectId: "dfy-christmas-tree-452d4",
    storageBucket: "dfy-christmas-tree-452d4.firebasestorage.app",
    messagingSenderId: "424198884902",
    appId: "1:424198884902:web:cb6e92e8abe3299c5160e7",
    measurementId: "G-7TTVR9EM4E"
  };

  // Firebase Ï¥àÍ∏∞Ìôî
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const storage = getStorage(app);
  const imagesCol = collection(db, "treeImages"); // Ïª¨Î†âÏÖò Ïù¥Î¶Ñ

  // --- Auth Ï¥àÍ∏∞Ìôî ---
  const auth = getAuth(app);
  const provider = new GoogleAuthProvider();

  // üî¥ Ïó¨Í∏∞Î•º Ïã§Ï†ú ÌöåÏÇ¨ Ïù¥Î©îÏùº ÎèÑÎ©îÏù∏ÏúºÎ°ú Î∞îÍøîÏ§ò
  // Ïòà: const ALLOWED_DOMAIN = "mycompany.co.kr";
  const ALLOWED_DOMAIN = "yourcompany.com";

  function isAllowedDomain(email) {
    return email && email.endsWith("@" + ALLOWED_DOMAIN);
  }

  // Ïù¥ÎØ∏ Ìä∏Î¶¨Ïóê Ï∂îÍ∞ÄÌïú Î¨∏ÏÑú id Í∏∞ÏñµÏö©
  const shownImageIds = new Set();

  window.addEventListener("load", () => {
    console.log("ÌéòÏù¥ÏßÄ Î°úÎìúÎê®");

    const loginBtn = document.getElementById("loginBtn");
    const logoutBtn = document.getElementById("logoutBtn");
    const userInfoEl = document.getElementById("userInfo");
    const fileInput = document.getElementById("fileInput");

    // Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Î≥ÄÌôî Í∞êÏßÄ
    onAuthStateChanged(auth, (user) => {
      if (user && isAllowedDomain(user.email)) {
        // ‚úÖ ÏÇ¨ÎÇ¥ Í≥ÑÏ†ïÏúºÎ°ú Î°úÍ∑∏Ïù∏
        userInfoEl.textContent = `Î°úÍ∑∏Ïù∏: ${user.email}`;
        loginBtn.style.display = "none";
        logoutBtn.style.display = "inline-block";
        fileInput.disabled = false;
      } else if (user && !isAllowedDomain(user.email)) {
        // ‚ùå Îã§Î•∏ ÎèÑÎ©îÏù∏ Í≥ÑÏ†ï
        userInfoEl.textContent = `ÌóàÏö©ÎêòÏßÄ ÏïäÏùÄ ÎèÑÎ©îÏù∏ÏûÖÎãàÎã§: ${user.email}`;
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "inline-block";
        fileInput.disabled = true;
      } else {
        // Î°úÍ∑∏Ïù∏ Ïïà Îêú ÏÉÅÌÉú
        userInfoEl.textContent = "Î°úÍ∑∏Ïù∏ ÌïÑÏöî (ÏÇ¨ÎÇ¥ Íµ¨Í∏Ä Í≥ÑÏ†ïÎßå Í∞ÄÎä•)";
        loginBtn.style.display = "inline-block";
        logoutBtn.style.display = "none";
        fileInput.disabled = true;
      }
    });

    // Î°úÍ∑∏Ïù∏ Î≤ÑÌäº
    loginBtn.addEventListener("click", async () => {
      try {
        await signInWithPopup(auth, provider);
      } catch (err) {
        console.error("Î°úÍ∑∏Ïù∏ Ïã§Ìå®", err);
        alert("Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. ÏΩòÏÜîÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
      }
    });

    // Î°úÍ∑∏ÏïÑÏõÉ Î≤ÑÌäº
    logoutBtn.addEventListener("click", async () => {
      try {
        await signOut(auth);
      } catch (err) {
        console.error("Î°úÍ∑∏ÏïÑÏõÉ Ïã§Ìå®", err);
      }
    });

    // === Ïó¨Í∏∞Î∂ÄÌÑ∞ Í∏∞Ï°¥ three.js / Firestore ÏΩîÎìú ===

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 6, 14);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x223355, 0.8);
    hemiLight.position.set(0, 1, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    const groundGeo = new THREE.CircleGeometry(18, 64);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x0b1220,
      metalness: 0.2,
      roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const treeHeight = 8;
    const treeRadius = 3;

    const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 1.5, 16);
    const trunkMat = new THREE.MeshStandardMaterial({
      color: 0x5b3a1e,
      roughness: 0.9
    });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 0.75;
    treeGroup.add(trunk);

    const treeGeo = new THREE.ConeGeometry(treeRadius, treeHeight, 32, 1, true);
    const treeMat = new THREE.MeshStandardMaterial({
      color: 0x0f766e,
      roughness: 0.6,
      metalness: 0.2
    });
    const tree = new THREE.Mesh(treeGeo, treeMat);
    tree.position.y = 0.75 + treeHeight / 2;
    treeGroup.add(tree);

    const starGeo = new THREE.OctahedronGeometry(0.4);
    const starMat = new THREE.MeshStandardMaterial({
      color: 0xfacc15,
      emissive: 0xfacc15,
      emissiveIntensity: 0.6,
      metalness: 0.9,
      roughness: 0.3
    });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.y = tree.position.y + treeHeight / 2 + 0.8;
    treeGroup.add(star);

    const snowCount = 600;
    const snowGeo = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(snowCount * 3);
    for (let i = 0; i < snowCount; i++) {
      snowPositions[i * 3 + 0] = (Math.random() - 0.5) * 40;
      snowPositions[i * 3 + 1] = Math.random() * 20 + 2;
      snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
    }
    snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPositions, 3));
    const snowMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.06
    });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    const countEl = document.getElementById("count");
    function updateCount(num) {
      countEl.textContent = `Í±∏Î¶∞ ÏÇ¨ÏßÑ: ${num}Ïû•`;
    }

    function getRandomPositionOnTree() {
      const yMin = tree.position.y - treeHeight / 2 + 0.5;
      const yMax = tree.position.y + treeHeight / 2 - 0.5;
      const y = yMin + Math.random() * (yMax - yMin);
      const normalizedHeight =
        (y - (tree.position.y - treeHeight / 2)) / treeHeight;
      const radiusAtY = treeRadius * (1 - normalizedHeight) + 0.2;

      const angle = Math.random() * Math.PI * 2;
      const x = Math.cos(angle) * radiusAtY;
      const z = Math.sin(angle) * radiusAtY;

      const position = new THREE.Vector3(x, y, z);
      return { position };
    }

    // --- Ïù¥ÎØ∏ÏßÄ Ìïú Ïû•ÏùÑ Ìä∏Î¶¨Ïóê Ï∂îÍ∞Ä ---
    function addImageToTree(imageUrl) {
      const texLoader = new THREE.TextureLoader();
      texLoader.load(
        imageUrl,
        (texture) => {
          const aspect = texture.image.width / texture.image.height;
          const baseHeight = 1.0;
          const width = baseHeight * aspect;
          const height = baseHeight;

          const geo = new THREE.PlaneGeometry(width, height);
          const mat = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(geo, mat);

          const { position } = getRandomPositionOnTree();
          plane.position.copy(position);
          plane.lookAt(new THREE.Vector3(0, position.y, 0));
          plane.rotateY(Math.PI);

          treeGroup.add(plane);
        },
        undefined,
        (err) => {
          console.error("ÌÖçÏä§Ï≤ò Î°úÎìú Ïò§Î•ò", err);
        }
      );
    }

    // --- FirestoreÏóêÏÑú Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ïù¥ÎØ∏ÏßÄ Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞ ---
    const q = query(imagesCol, orderBy("createdAt", "asc"));
    onSnapshot(q, (snapshot) => {
      console.log("Firestore snapshot size:", snapshot.size);

      snapshot.docs.forEach((doc) => {
        const id = doc.id;
        if (shownImageIds.has(id)) return;
        shownImageIds.add(id);

        const data = doc.data();
        if (data.url) {
          console.log("addImageFromDoc:", id, data.url);
          addImageToTree(data.url);
        }
      });

      updateCount(snapshot.size);
    });

    // --- ÌååÏùº ÏóÖÎ°úÎìú ‚Üí StorageÏóê Ïò¨Î¶¨Í≥† URLÏùÑ FirestoreÏóê Ï†ÄÏû• ---
    async function uploadAndRegister(file) {
      const filePath = `uploads/${Date.now()}_${file.name}`;
      const storageRef = ref(storage, filePath);
      const snapshot = await uploadBytes(storageRef, file);
      const downloadURL = await getDownloadURL(snapshot.ref);

      await addDoc(imagesCol, {
        url: downloadURL,
        createdAt: serverTimestamp()
      });
    }

    fileInput.addEventListener("change", (event) => {
      const files = event.target.files;
      if (!files || !files.length) return;

      // ÌòπÏãúÎùºÎèÑ Î≤ÑÌäº ÏÉÅÌÉú Íº¨ÏòÄÏùÑ ÎïåÎ•º ÎåÄÎπÑÌï¥ÏÑú Ìïú Î≤à Îçî Ï≤¥ÌÅ¨
      const user = auth.currentUser;
      if (!user || !isAllowedDomain(user.email)) {
        alert("ÏÇ¨ÎÇ¥ Íµ¨Í∏Ä Í≥ÑÏ†ïÏúºÎ°ú Î°úÍ∑∏Ïù∏Ìï¥Ïïº ÏóÖÎ°úÎìúÌï† Ïàò ÏûàÏäµÎãàÎã§.");
        fileInput.value = "";
        return;
      }

      Array.from(files).forEach((file) => {
        if (!file.type.startsWith("image/")) return;
        uploadAndRegister(file).catch((err) =>
          console.error("ÏóÖÎ°úÎìú Ïã§Ìå®", err)
        );
      });

      fileInput.value = "";
    });

    // === ÎìúÎûòÍ∑∏ ÌöåÏ†Ñ / Ìú† Ï§å, Î¶¨ÏÇ¨Ïù¥Ï¶à, Ïï†ÎãàÎ©îÏù¥ÏÖò Î£®ÌîÑ ===
    let isDragging = false;
    let prevX = 0;
    let prevY = 0;
    const dragRotateSpeed = 0.005;

    renderer.domElement.addEventListener("mousedown", (event) => {
      isDragging = true;
      prevX = event.clientX;
      prevY = event.clientY;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });

    window.addEventListener("mousemove", (event) => {
      if (!isDragging) return;
      const deltaX = event.clientX - prevX;
      const deltaY = event.clientY - prevY;
      prevX = event.clientX;
      prevY = event.clientY;

      treeGroup.rotation.y += deltaX * dragRotateSpeed;
      const newX = THREE.MathUtils.clamp(
        treeGroup.rotation.x + deltaY * dragRotateSpeed,
        -Math.PI / 6,
        Math.PI / 6
      );
      treeGroup.rotation.x = newX;
    });

    renderer.domElement.addEventListener("wheel", (event) => {
      event.preventDefault();
      const zoomSpeed = 0.002;
      const delta = event.deltaY * zoomSpeed;
      const minDist = 8;
      const maxDist = 25;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      const newPos = camera.position.clone().addScaledVector(dir, delta * 20);
      const distance = newPos.length();

      if (distance > minDist && distance < maxDist) {
        camera.position.copy(newPos);
      }
    }, { passive: false });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    let lastTime = 0;
    function animate(time) {
      requestAnimationFrame(animate);
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (!isDragging) {
        treeGroup.rotation.y += delta * 0.2;
      }
      star.rotation.y -= delta * 0.4;

      const pos = snowGeo.attributes.position;
      for (let i = 0; i < snowCount; i++) {
        let y = pos.getY(i);
        y -= delta * (0.5 + Math.random() * 0.3);
        if (y < 0.5) {
          y = Math.random() * 20 + 5;
        }
        pos.setY(i, y);
      }
      pos.needsUpdate = true;

      camera.lookAt(0, tree.position.y, 0);
      renderer.render(scene, camera);
    }
    animate(0);
  });
  </script>
</body>
</html>
