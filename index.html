<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>í¬ë¦¬ìŠ¤ë§ˆìŠ¤ íŠ¸ë¦¬ ê°¤ëŸ¬ë¦¬</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 16px;
      left: 16px;
      padding: 12px 16px;
      background: rgba(15,23,42,0.9);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      z-index: 10;
      max-width: 260px;
    }
    #ui h1 {
      font-size: 16px;
      margin-bottom: 8px;
    }
    #fileInput {
      margin-top: 6px;
      font-size: 12px;
    }
    #count {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.8;
    }
    button {
      border: none;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      background: #22c55e;
      color: #022c22;
    }
    button.secondary {
      background: #0f172a;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>ğŸ„ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ íŠ¸ë¦¬ ê°¤ëŸ¬ë¦¬</h1>
    <div style="font-size: 13px;">ì´ë¯¸ì§€ë¥¼ ì˜¬ë¦¬ë©´ íŠ¸ë¦¬ì— ê±¸ë ¤ìš”.</div>

    <!-- ë¡œê·¸ì¸ ìƒíƒœ í‘œì‹œ -->
    <div id="userInfo"
        style="margin-top: 6px; font-size: 12px; opacity: .9;">
      ë¡œê·¸ì¸ í•„ìš” (ì‚¬ë‚´ êµ¬ê¸€ ê³„ì •ë§Œ ê°€ëŠ¥)
    </div>

    <!-- ë¡œê·¸ì¸ / ë¡œê·¸ì•„ì›ƒ ë²„íŠ¼ -->
    <div style="margin-top: 6px; display: flex; gap: 6px;">
      <button id="loginBtn"
              style="font-size: 12px; padding: 4px 8px; border-radius: 6px; border:none; cursor:pointer; background:#22c55e; color:#022c22;">
        Google ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
      </button>
      <button id="logoutBtn"
              style="font-size: 12px; padding: 4px 8px; border-radius: 6px; border:1px solid #1f2937; background:#0f172a; color:#e5e7eb; cursor:pointer; display:none;">
        ë¡œê·¸ì•„ì›ƒ
      </button>
    </div>

    <!-- íŒŒì¼ ì—…ë¡œë“œ (ì²˜ìŒì—” ë§‰ì•„ë‘ ) -->
    <input id="fileInput" type="file" multiple accept="image/*" disabled />
    <div id="count">ê±¸ë¦° ì‚¬ì§„: 0ì¥</div>
  </div>

  <!-- three.js (r150.1, ì˜ˆì „ ë°©ì‹ ì§€ì›) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

  <script type="module">
  // ===== Firebase CDN import =====
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-app.js';
  import {
    getFirestore,
    collection,
    addDoc,
    onSnapshot,
    query,
    orderBy,
    serverTimestamp
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js';
  import {
    getStorage,
    ref,
    uploadBytes,
    getDownloadURL
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-storage.js';
  import {
    getAuth,
    onAuthStateChanged,
    signInWithPopup,
    GoogleAuthProvider,
    signOut
  } from 'https://www.gstatic.com/firebasejs/12.5.0/firebase-auth.js';

  // === Firebase ì„¤ì • ===
  const firebaseConfig = {
    apiKey: "AIzaSyB_bZoaw6cvdrot7DEabrXsfyDYM-ZgaR0",
    authDomain: "dfy-christmas-tree-452d4.firebaseapp.com",
    projectId: "dfy-christmas-tree-452d4",
    storageBucket: "dfy-christmas-tree-452d4.firebasestorage.app",
    messagingSenderId: "424198884902",
    appId: "1:424198884902:web:cb6e92e8abe3299c5160e7",
    measurementId: "G-7TTVR9EM4E"
  };

  // Firebase ì´ˆê¸°í™”
  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const storage = getStorage(app);
  const imagesCol = collection(db, "treeImages");

  // --- Auth ì´ˆê¸°í™” ---
  const auth = getAuth(app);
  const provider = new GoogleAuthProvider();

  // ğŸ”´ ì—¬ê¸°ë¥¼ ì‹¤ì œ íšŒì‚¬ ì´ë©”ì¼ ë„ë©”ì¸ìœ¼ë¡œ ë°”ê¿”ì¤˜
  // ì˜ˆ: const ALLOWED_DOMAIN = "mycompany.co.kr";
  const ALLOWED_DOMAIN = "dfy.co.kr";

  function isAllowedDomain(email) {
    return email && email.endsWith("@" + ALLOWED_DOMAIN);
  }


  // ì´ë¯¸ íŠ¸ë¦¬ì— ì¶”ê°€í•œ ë¬¸ì„œ id ê¸°ì–µìš©
  const shownImageIds = new Set();

  window.addEventListener("load", () => {
    console.log("í˜ì´ì§€ ë¡œë“œë¨");

    const loginBtn   = document.getElementById("loginBtn");
    const logoutBtn  = document.getElementById("logoutBtn");
    const userInfoEl = document.getElementById("userInfo");
    const fileInput  = document.getElementById("fileInput");

    // ë¡œê·¸ì¸ ìƒíƒœ ë³€í™” ê°ì§€
    onAuthStateChanged(auth, (user) => {
      if (user && isAllowedDomain(user.email)) {
        // âœ… ì‚¬ë‚´ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸
        userInfoEl.textContent = `ë¡œê·¸ì¸: ${user.email}`;
        loginBtn.style.display  = "none";
        logoutBtn.style.display = "inline-block";
        fileInput.disabled      = false;
      } else if (user && !isAllowedDomain(user.email)) {
        // âŒ êµ¬ê¸€ì´ê¸´ í•œë° ë‹¤ë¥¸ ë„ë©”ì¸
        userInfoEl.textContent = `í—ˆìš©ë˜ì§€ ì•Šì€ ë„ë©”ì¸ì…ë‹ˆë‹¤: ${user.email}`;
        loginBtn.style.display  = "inline-block";
        logoutBtn.style.display = "inline-block";
        fileInput.disabled      = true;
      } else {
        // ë¡œê·¸ì¸ ì•ˆ ëœ ìƒíƒœ
        userInfoEl.textContent = "ë¡œê·¸ì¸ í•„ìš” (ì‚¬ë‚´ êµ¬ê¸€ ê³„ì •ë§Œ ê°€ëŠ¥)";
        loginBtn.style.display  = "inline-block";
        logoutBtn.style.display = "none";
        fileInput.disabled      = true;
      }
    });

    // ë¡œê·¸ì¸ ë²„íŠ¼
    loginBtn.addEventListener("click", async () => {
      try {
        await signInWithPopup(auth, provider);
      } catch (err) {
        console.error("ë¡œê·¸ì¸ ì‹¤íŒ¨", err);
        alert("ë¡œê·¸ì¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì½˜ì†”ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
      }
    });

    // ë¡œê·¸ì•„ì›ƒ ë²„íŠ¼
    logoutBtn.addEventListener("click", async () => {
      try {
        await signOut(auth);
      } catch (err) {
        console.error("ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨", err);
      }
    });

    // ğŸ”½ ì´ ì•„ë˜ë¶€í„°ëŠ” ê¸°ì¡´ three.js / Firestore ì½”ë“œ ê·¸ëŒ€ë¡œ ìœ ì§€
    // const scene = new THREE.Scene(); ...


    // === ì—¬ê¸°ë¶€í„° ê¸°ì¡´ three.js / Firestore ì½”ë“œ ===

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x020617);

    const camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 6, 14);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x223355, 0.8);
    hemiLight.position.set(0, 1, 0);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);

    const groundGeo = new THREE.CircleGeometry(18, 64);
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x0b1220,
      metalness: 0.2,
      roughness: 0.8
    });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    const treeHeight = 8;
    const treeRadius = 3;

    const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 1.5, 16);
    const trunkMat = new THREE.MeshStandardMaterial({
      color: 0x5b3a1e,
      roughness: 0.9
    });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 0.75;
    treeGroup.add(trunk);

    const treeGeo = new THREE.ConeGeometry(treeRadius, treeHeight, 32, 1, true);
    const treeMat = new THREE.MeshStandardMaterial({
      color: 0x0f766e,
      roughness: 0.6,
      metalness: 0.2
    });
    const tree = new THREE.Mesh(treeGeo, treeMat);
    tree.position.y = 0.75 + treeHeight / 2;
    treeGroup.add(tree);

    const starGeo = new THREE.OctahedronGeometry(0.4);
    const starMat = new THREE.MeshStandardMaterial({
      color: 0xfacc15,
      emissive: 0xfacc15,
      emissiveIntensity: 0.6,
      metalness: 0.9,
      roughness: 0.3
    });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.y = tree.position.y + treeHeight / 2 + 0.8;
    treeGroup.add(star);

    const snowCount = 600;
    const snowGeo = new THREE.BufferGeometry();
    const snowPositions = new Float32Array(snowCount * 3);
    for (let i = 0; i < snowCount; i++) {
      snowPositions[i * 3 + 0] = (Math.random() - 0.5) * 40;
      snowPositions[i * 3 + 1] = Math.random() * 20 + 2;
      snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
    }
    snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPositions, 3));
    const snowMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.06
    });
    const snow = new THREE.Points(snowGeo, snowMat);
    scene.add(snow);

    const countEl = document.getElementById("count");
    function updateCount(num) {
      countEl.textContent = `ê±¸ë¦° ì‚¬ì§„: ${num}ì¥`;
    }

    function getRandomPositionOnTree() {
      const yMin = tree.position.y - treeHeight / 2 + 0.5;
      const yMax = tree.position.y + treeHeight / 2 - 0.5;
      const y = yMin + Math.random() * (yMax - yMin);
      const normalizedHeight =
        (y - (tree.position.y - treeHeight / 2)) / treeHeight;
      const radiusAtY = treeRadius * (1 - normalizedHeight) + 0.2;

      const angle = Math.random() * Math.PI * 2;
      const x = Math.cos(angle) * radiusAtY;
      const z = Math.sin(angle) * radiusAtY;

      const position = new THREE.Vector3(x, y, z);
      return { position };
    }

    // --- ì´ë¯¸ì§€ í•œ ì¥ì„ íŠ¸ë¦¬ì— ì¶”ê°€ ---
    function addImageToTree(imageUrl) {
      const texLoader = new THREE.TextureLoader();
      texLoader.load(
        imageUrl,
        (texture) => {
          const aspect = texture.image.width / texture.image.height;
          const baseHeight = 1.0;
          const width = baseHeight * aspect;
          const height = baseHeight;

          const geo = new THREE.PlaneGeometry(width, height);
          const mat = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide
          });
          const plane = new THREE.Mesh(geo, mat);

          const { position } = getRandomPositionOnTree();
          plane.position.copy(position);
          plane.lookAt(new THREE.Vector3(0, position.y, 0));
          plane.rotateY(Math.PI);

          treeGroup.add(plane);
        },
        undefined,
        (err) => {
          console.error("í…ìŠ¤ì²˜ ë¡œë“œ ì˜¤ë¥˜", err);
        }
      );
    }

    // --- Firestoreì—ì„œ ì‹¤ì‹œê°„ìœ¼ë¡œ ì´ë¯¸ì§€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ---
    const q = query(imagesCol, orderBy("createdAt", "asc"));
    onSnapshot(q, (snapshot) => {
      console.log("Firestore snapshot size:", snapshot.size);

      snapshot.docs.forEach((doc) => {
        const id = doc.id;
        if (shownImageIds.has(id)) return;
        shownImageIds.add(id);

        const data = doc.data();
        if (data.url) {
          console.log("addImageFromDoc:", id, data.url);
          addImageToTree(data.url);
        }
      });

      updateCount(snapshot.size);
    });

    // --- íŒŒì¼ ì—…ë¡œë“œ â†’ Storageì— ì˜¬ë¦¬ê³  URLì„ Firestoreì— ì €ì¥ ---
    async function uploadAndRegister(file) {
      const filePath = `uploads/${Date.now()}_${file.name}`;
      const storageRef = ref(storage, filePath);
      const snapshot = await uploadBytes(storageRef, file);
      const downloadURL = await getDownloadURL(snapshot.ref);

      await addDoc(imagesCol, {
        url: downloadURL,
        createdAt: serverTimestamp()
      });
    }

    fileInput.addEventListener("change", (event) => {
      const files = event.target.files;
      if (!files || !files.length) return;

      // ë§ˆì§€ë§‰ ë°©ì–´: ì‹¤ì œë¡œ ë¡œê·¸ì¸ + íšŒì‚¬ ë„ë©”ì¸ì¸ì§€ í™•ì¸
      const user = auth.currentUser;
      if (!user || !isAllowedDomain(user.email)) {
        alert("ì‚¬ë‚´ êµ¬ê¸€ ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•´ì•¼ ì—…ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
        fileInput.value = "";
        return;
      }

      Array.from(files).forEach((file) => {
        if (!file.type.startsWith("image/")) return;
        uploadAndRegister(file).catch((err) =>
          console.error("ì—…ë¡œë“œ ì‹¤íŒ¨", err)
        );
      });

      fileInput.value = "";
    });


    // === ë“œë˜ê·¸ íšŒì „ / íœ  ì¤Œ, ë¦¬ì‚¬ì´ì¦ˆ, ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„ ===
    let isDragging = false;
    let prevX = 0;
    let prevY = 0;
    const dragRotateSpeed = 0.005;

    renderer.domElement.addEventListener("mousedown", (event) => {
      isDragging = true;
      prevX = event.clientX;
      prevY = event.clientY;
    });

    window.addEventListener("mouseup", () => {
      isDragging = false;
    });

    window.addEventListener("mousemove", (event) => {
      if (!isDragging) return;
      const deltaX = event.clientX - prevX;
      const deltaY = event.clientY - prevY;
      prevX = event.clientX;
      prevY = event.clientY;

      treeGroup.rotation.y += deltaX * dragRotateSpeed;
      const newX = THREE.MathUtils.clamp(
        treeGroup.rotation.x + deltaY * dragRotateSpeed,
        -Math.PI / 6,
        Math.PI / 6
      );
      treeGroup.rotation.x = newX;
    });

    renderer.domElement.addEventListener("wheel", (event) => {
      event.preventDefault();
      const zoomSpeed = 0.002;
      const delta = event.deltaY * zoomSpeed;
      const minDist = 8;
      const maxDist = 25;

      const dir = new THREE.Vector3();
      camera.getWorldDirection(dir);

      const newPos = camera.position.clone().addScaledVector(dir, delta * 20);
      const distance = newPos.length();

      if (distance > minDist && distance < maxDist) {
        camera.position.copy(newPos);
      }
    }, { passive: false });

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    let lastTime = 0;
    function animate(time) {
      requestAnimationFrame(animate);
      const delta = (time - lastTime) / 1000;
      lastTime = time;

      if (!isDragging) {
        treeGroup.rotation.y += delta * 0.2;
      }
      star.rotation.y -= delta * 0.4;

      const pos = snowGeo.attributes.position;
      for (let i = 0; i < snowCount; i++) {
        let y = pos.getY(i);
        y -= delta * (0.5 + Math.random() * 0.3);
        if (y < 0.5) {
          y = Math.random() * 20 + 5;
        }
        pos.setY(i, y);
      }
      pos.needsUpdate = true;

      camera.lookAt(0, tree.position.y, 0);
      renderer.render(scene, camera);
    }
    animate(0);
  });
  </script>
</body>
</html>
