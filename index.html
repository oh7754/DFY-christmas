<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>í¬ë¦¬ìŠ¤ë§ˆìŠ¤ íŠ¸ë¦¬ ê°¤ëŸ¬ë¦¬</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #020617;
      color: #f9fafb;
      overflow: hidden;
    }
    #ui {
      position: fixed;
      top: 16px;
      left: 16px;
      padding: 12px 16px;
      background: rgba(15,23,42,0.9);
      border-radius: 12px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 30px rgba(0,0,0,0.4);
      z-index: 10;
    }
    #ui h1 {
      font-size: 16px;
      margin-bottom: 8px;
    }
    #fileInput {
      margin-top: 6px;
      font-size: 12px;
    }
    #count {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.8;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <h1>ğŸ„ í¬ë¦¬ìŠ¤ë§ˆìŠ¤ íŠ¸ë¦¬ ê°¤ëŸ¬ë¦¬</h1>
    <div style="font-size: 13px;">ì´ë¯¸ì§€ë¥¼ ì˜¬ë¦¬ë©´ íŠ¸ë¦¬ì— ê±¸ë ¤ìš”.</div>
    <input id="fileInput" type="file" multiple accept="image/*" />
    <div id="count">ê±¸ë¦° ì‚¬ì§„: 0ì¥</div>
  </div>

  <!-- three.js (r150.1, ì˜ˆì „ ë°©ì‹ ì§€ì›) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>

  <script>
    window.addEventListener("load", () => {
      console.log("í˜ì´ì§€ ë¡œë“œë¨");

      // === ê¸°ë³¸ ì„¸íŒ… ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 6, 14);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // íŠ¸ë¦¬/ì¥ì‹ë“¤ì„ ë‹´ì„ ê·¸ë£¹
      const treeGroup = new THREE.Group();
      scene.add(treeGroup);

      // === ì¡°ëª… ===
      const hemiLight = new THREE.HemisphereLight(0xffffff, 0x223355, 0.8);
      hemiLight.position.set(0, 1, 0);
      scene.add(hemiLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
      dirLight.position.set(5, 10, 5);
      scene.add(dirLight);

      // === ë°”ë‹¥ ===
      const groundGeo = new THREE.CircleGeometry(18, 64);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x0b1220,
        metalness: 0.2,
        roughness: 0.8
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // === íŠ¸ë¦¬ ëª¸í†µ + ê¸°ë‘¥ ===
      const treeHeight = 8;
      const treeRadius = 3;

      const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 1.5, 16);
      const trunkMat = new THREE.MeshStandardMaterial({
        color: 0x5b3a1e,
        roughness: 0.9
      });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 0.75;
      treeGroup.add(trunk);

      const treeGeo = new THREE.ConeGeometry(treeRadius, treeHeight, 32, 1, true);
      const treeMat = new THREE.MeshStandardMaterial({
        color: 0x0f766e,
        roughness: 0.6,
        metalness: 0.2
      });
      const tree = new THREE.Mesh(treeGeo, treeMat);
      tree.position.y = 0.75 + treeHeight / 2;
      treeGroup.add(tree);

      // === ë³„ ===
      const starGeo = new THREE.OctahedronGeometry(0.4);
      const starMat = new THREE.MeshStandardMaterial({
        color: 0xfacc15,
        emissive: 0xfacc15,
        emissiveIntensity: 0.6,
        metalness: 0.9,
        roughness: 0.3
      });
      const star = new THREE.Mesh(starGeo, starMat);
      star.position.y = tree.position.y + treeHeight / 2 + 0.8;
      treeGroup.add(star);

      // === ëˆˆ íŒŒí‹°í´ ===
      const snowCount = 600;
      const snowGeo = new THREE.BufferGeometry();
      const snowPositions = new Float32Array(snowCount * 3);
      for (let i = 0; i < snowCount; i++) {
        snowPositions[i * 3 + 0] = (Math.random() - 0.5) * 40;
        snowPositions[i * 3 + 1] = Math.random() * 20 + 2;
        snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 40;
      }
      snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPositions, 3));
      const snowMat = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.06
      });
      const snow = new THREE.Points(snowGeo, snowMat);
      scene.add(snow);

      // === ì—…ë¡œë“œëœ ì‚¬ì§„ ê´€ë¦¬ ===
      const uploadedPictures = [];
      const countEl = document.getElementById("count");

      function updateCount() {
        countEl.textContent = `ê±¸ë¦° ì‚¬ì§„: ${uploadedPictures.length}ì¥`;
      }

      // íŠ¸ë¦¬ í‘œë©´ ìœ„ ëœë¤ ìœ„ì¹˜
      function getRandomPositionOnTree() {
        const yMin = tree.position.y - treeHeight / 2 + 0.5;
        const yMax = tree.position.y + treeHeight / 2 - 0.5;
        const y = yMin + Math.random() * (yMax - yMin);

        const normalizedHeight =
          (y - (tree.position.y - treeHeight / 2)) / treeHeight; // 0~1
        const radiusAtY = treeRadius * (1 - normalizedHeight) + 0.2;

        const angle = Math.random() * Math.PI * 2;
        const x = Math.cos(angle) * radiusAtY;
        const z = Math.sin(angle) * radiusAtY;

        const position = new THREE.Vector3(x, y, z);
        return { position };
      }

      function addImageToTree(imageUrl) {
        const texLoader = new THREE.TextureLoader();
        texLoader.load(
          imageUrl,
          (texture) => {
            const aspect = texture.image.width / texture.image.height;
            const baseHeight = 1.0;
            const width = baseHeight * aspect;
            const height = baseHeight;

            const geo = new THREE.PlaneGeometry(width, height);
            const mat = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true,
              side: THREE.DoubleSide
            });
            const plane = new THREE.Mesh(geo, mat);

            const { position } = getRandomPositionOnTree();
            plane.position.copy(position);

            plane.lookAt(new THREE.Vector3(0, position.y, 0));
            plane.rotateY(Math.PI);

            treeGroup.add(plane); // íŠ¸ë¦¬ì™€ í•¨ê»˜ ë„ëŠ” ê·¸ë£¹ì— ì¶”ê°€
            uploadedPictures.push(plane);
            updateCount();
          },
          undefined,
          (err) => {
            console.error("í…ìŠ¤ì²˜ ë¡œë“œ ì˜¤ë¥˜", err);
          }
        );
      }

      // === íŒŒì¼ ì—…ë¡œë“œ ===
      const fileInput = document.getElementById("fileInput");
      fileInput.addEventListener("change", (event) => {
        const files = event.target.files;
        if (!files || !files.length) return;

        Array.from(files).forEach((file) => {
          if (!file.type.startsWith("image/")) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            const imageUrl = e.target.result;
            addImageToTree(imageUrl);
          };
          reader.readAsDataURL(file);
        });

        fileInput.value = "";
      });

      // === ë§ˆìš°ìŠ¤ ë“œë˜ê·¸ë¡œ íŠ¸ë¦¬ íšŒì „ ===
      let isDragging = false;
      let prevX = 0;
      let prevY = 0;
      const dragRotateSpeed = 0.005;

      renderer.domElement.addEventListener("mousedown", (event) => {
        isDragging = true;
        prevX = event.clientX;
        prevY = event.clientY;
      });

      window.addEventListener("mouseup", () => {
        isDragging = false;
      });

      window.addEventListener("mousemove", (event) => {
        if (!isDragging) return;
        const deltaX = event.clientX - prevX;
        const deltaY = event.clientY - prevY;
        prevX = event.clientX;
        prevY = event.clientY;

        // ì¢Œìš° ë“œë˜ê·¸ë¡œ Yì¶• íšŒì „
        treeGroup.rotation.y += deltaX * dragRotateSpeed;
        // ìœ„ì•„ë˜ ë“œë˜ê·¸ë¡œ ì•½ê°„ ìˆ™ì´ê³  ë“¤ê¸° (ì œí•œ)
        const newX = THREE.MathUtils.clamp(
          treeGroup.rotation.x + deltaY * dragRotateSpeed,
          -Math.PI / 6,
          Math.PI / 6
        );
        treeGroup.rotation.x = newX;
      });

      // === íœ ë¡œ ì¤Œ ì¸/ì•„ì›ƒ ===
      renderer.domElement.addEventListener("wheel", (event) => {
        event.preventDefault();
        const zoomSpeed = 0.002;
        const delta = event.deltaY * zoomSpeed;
        const minDist = 8;
        const maxDist = 25;

        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir); // ì¹´ë©”ë¼ ì‹œì„  ë°©í–¥

        const newPos = camera.position.clone().addScaledVector(dir, delta * 20);
        const distance = newPos.length();

        if (distance > minDist && distance < maxDist) {
          camera.position.copy(newPos);
        }
      }, { passive: false });

      // === ë¦¬ì‚¬ì´ì¦ˆ ===
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // === ë Œë” ë£¨í”„ ===
      let lastTime = 0;
      function animate(time) {
        requestAnimationFrame(animate);
        const delta = (time - lastTime) / 1000;
        lastTime = time;

        // ìë™ìœ¼ë¡œ ì‚´ì§ íšŒì „ (ë“œë˜ê·¸ ì•ˆ í•  ë•Œ)
        if (!isDragging) {
          treeGroup.rotation.y += delta * 0.2;
        }
        star.rotation.y -= delta * 0.4;

        // ëˆˆ ë–¨ì–´ì§€ëŠ” ì• ë‹ˆë©”ì´ì…˜
        const pos = snowGeo.attributes.position;
        for (let i = 0; i < snowCount; i++) {
          let y = pos.getY(i);
          y -= delta * (0.5 + Math.random() * 0.3);
          if (y < 0.5) {
            y = Math.random() * 20 + 5;
          }
          pos.setY(i, y);
        }
        pos.needsUpdate = true;

        // ì¹´ë©”ë¼ëŠ” í•­ìƒ íŠ¸ë¦¬ ì¤‘ì•™ì„ ë°”ë¼ë³´ê²Œ
        camera.lookAt(0, tree.position.y, 0);

        renderer.render(scene, camera);
      }
      animate(0);
    });
  </script>
</body>
</html>
